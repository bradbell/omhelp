/* ----------------------------------------------------------------------------
OMhelp: Language Independent Embedded Documentation
          Copyright (C) 1998-2015 Bradley M. Bell
OMhelp is distributed under the terms of the
            GNU General Public License Version 2.
---------------------------------------------------------------------------- */
/*
Lexical analyizer for OMhelp commands
------------------------------------------------------------------------------
$begin CommandKeyCharacter$$
$dollar @$$
$spell
	OMhelp
	omhlex
$$


$section The Current Command Key Character$$

$head Syntax$$
$codei%SetCommandKeyCharacter()
%$$
$codei%GetCommandKeyCharacter()
%$$

$head @OMhelpKeyCharacter$$
The user input
$codei%
	@OMhelpKeyCharacter=%c%
%$$
changes the current command key character to the
one specified by $icode c$$ where
$icode c$$ is not an alphabetic letter, a decimal digit, or
white space.

$head GetCommandKeyCharacter$$
The function call
$codei%
	GetCommandKeyCharacter()
%$$
returns the current command key character.

$head SetCommandKeyCharacter$$
If $icode c$$ has prototype
$codei%
	char %c%
%$$
The function call
$codei%
	SetCommandKeyCharacter(c)
%$$
sets the current command key character to the value
specified by $icode c$$.

$head End of File$$
The current command key character is changed back to $code @$$ at
the end of every file; i.e., just before $code EOF_lex$$ is returned
by $code omhlex$$.
For this reason, the string portion of a $code EOF_lex$$ token
is set to the current key character just before the end of file.


$end
------------------------------------------------------------------------------
$begin TokenCode2String$$
$spell
	Mem
$$

$section Converting Integer Token Code to User Input$$

$head Syntax$$
$icode%string% = TokenCode2String(%code%)%$$


$head Purpose$$
The lexical analyzer now passes back token integer codes for error reporting.
This routine converts the integer code to the corresponding users input
(including the @ character).

$head code$$
The argument $icode code$$ has prototype
$codei%
	int %code%
%$$
It is the integer code for the token to be converted.

$head string$$
The result $icode string$$ has prototype
$codei%
	char *%string%
%$$
It points to memory that
should be freed using the routine $cref/FreeMem/AllocMem/FreeMem/$$
when it is no longer needed.
If this memory is not freed,
a call to
$cref/CheckMemoryLeak/AllocMem/CheckMemoryLeak/$$
will report the corresponding source code line in the routine
$code TokenCode2String$$.

$end
*/

#ifdef WIN32
# include <conio.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>

# include "strjoin.h"
# include "allocmem.h"
# include "input.h"
# include "fatalerr.h"
# include "str_alloc.h"
# include "OmhLexSetInputLine.h"
# include "BinarySearch.h"
# include "int2str.h"

# include "OmhStype.h"
# define YYSTYPE OmhStype

// include file for this file
# include "lexomh.h"

// automatically generated include file generated by yacc from omhelp.y
# include "omhelp.h"

// maximum number of characters in a token
# define MAX_TOKEN    100000

// debug execution of lexical analyzer
# define DEBUG_TOKENS 0

static char CommandKeyChar = '$';

char GetCommandKeyCharacter(void)
{	return CommandKeyChar; }

void SetCommandKeyCharacter(char c)
{	CommandKeyChar = c; }

static enum state {
	EOF_state,
	EMPTY_state,
	KEY_state,
	BEGIN_state,
	CHANGE_state,
	OMHELP_state,
	LATEX_state
} State;

static int Initialize  = 1;

static int CurrentLine;
static char Buffer[MAX_TOKEN];
static char Ch;


static struct
{	char *name;  // The keywords name
	int  code;   // The corresponding integer code defined by bison
}
keyword_table[] =
{
	{ "aindex",     AINDEX_lex      },
	{ "align",      ALIGN_lex       },
	{ "begin",      BEGIN_lex       },
	{ "bgcolor",    BGCOLOR_lex     },
	{ "big",        BIG_lex         },
	{ "bold",       BOLD_lex        },
	{ "cend",       CEND_lex        },
	{ "center",     CENTER_lex      },
	{ "children",   CHILDREN_lex    },
	{ "childtable", CHILDTABLE_lex  },
	{ "cindex",     CINDEX_lex      },
	{ "cmark",      CMARK_lex       },
	{ "cnext",      CNEXT_lex       },
	{ "code",       CODE_lex        },
	{ "codecolor",  CODECOLOR_lex   },
	{ "codei",      CODEI_lex       },
	{ "codep",      CODEP_lex       },
	{ "comment",    COMMENT_lex     },
	{ "contents",   CONTENTS_lex    },
	{ "cref",       CREF_lex        },
	{ "date",       DATE_lex        },
	{ "dollar",     DOLLAR_lex      },
	{ "end",        END_lex         },
	{ "errorcolor", ERRORCOLOR_lex  },
	{ "escape",     ESCAPE_lex      },
	{ "execute",    EXECUTE_lex     },
	{ "fend",       FEND_lex        },
	{ "fixed",      FIXED_lex       },
	{ "head",       HEAD_lex        },
	{ "hilitecmd",  HILITECMD_lex   },
	{ "hilitecolor",HILITECOLOR_lex },
	{ "hiliteseq",  HILITESEQ_lex   },
	{ "href",       HREF_lex        },
	{ "icode",      ICODE_lex       },
	{ "icon",       ICON_lex        },
	{ "image",      IMAGE_lex       },
	{ "include",    INCLUDE_lex     },
	{ "index",      INDEX_lex       },
	{ "italic",     ITALIC_lex      },
	{ "latex",      LATEX_lex       },
	{ "lend",       LEND_lex        },
	{ "linkcolor",  LINKCOLOR_lex   },
	{ "list",       LIST_lex        },
	{ "lnext",      LNEXT_lex       },
	{ "math",       MATH_lex        },
	{ "mindex",     MINDEX_lex      },
	{ "mref",       MREF_lex        },
	{ "navigate",   NAVIGATE_lex    },
	{ "newlinech",  NEWLINECH_lex   },
	{ "nobreak",    NOBREAK_lex     },
	{ "nospell",    NOSPELL_lex     },
	{ "path",       PATH_lex        },
	{ "pre",        PRE_lex         },
	{ "rend",       REND_lex        },
	{ "rmark",      RMARK_lex       },
	{ "rnext",      RNEXT_lex       },
	{ "rref",       RREF_lex        },
	{ "section",    SECTION_lex     },
	{ "skipnl",     SKIPNL_lex      },
	{ "small",      SMALL_lex       },
	{ "spell",      SPELL_lex       },
	{ "srcfile",    SRCFILE_lex     },
	{ "subhead",    SUBHEAD_lex     },
	{ "syntax",     SYNTAX_lex      },
	{ "table",      TABLE_lex       },
	{ "tabsize",    TABSIZE_lex     },
	{ "tend",       TEND_lex        },
	{ "textcolor",  TEXTCOLOR_lex   },
	{ "th",         TH_lex          },
	{ "title",      TITLE_lex       },
	{ "trace",      TRACE_lex       },
	{ "tref",       TREF_lex        },
	{ "verbatim",   VERBATIM_lex    },
	{ "visitcolor", VISITCOLOR_lex  },
	{ "wspace",     WSPACE_lex      },
	{ "xref",       XREF_lex        }
};
static int n_keyword   = sizeof keyword_table / sizeof keyword_table[0];
static const char *Key[  sizeof keyword_table / sizeof keyword_table[0] ];

char *TokenCode2String(int code)
{	int i;
	for(i = 0; i < n_keyword; i++)
		if( keyword_table[i].code == code )
			return strjoin("$", keyword_table[i].name);
	switch( code )
	{
		case ACCENT_lex:
		return str_alloc("$'");

		case EOF_lex:
		return str_alloc("eof");

		case DOUBLE_DOLLAR_lex:
		return str_alloc("$$");

		case NUMBER_lex:
		return str_alloc("$<number>");

		case TEXT_lex:
		return str_alloc("<text>");
	}
	assert(0);
	return str_alloc("<TokenCode2String: OMhelp program error.>");
}


// routine to set return value for parser (omhelp.y)
static void SetOmhLvalStr(int code, const char *token, const char *str)
{
	if( DEBUG_TOKENS )
		printf("\nLex(%s) ", token);

	omhlval.code = code;
	omhlval.line = CurrentLine;

	if( str == NULL )
		omhlval.str = NULL;
	else	omhlval.str  = str_alloc(str);


	CurrentLine = InputLine();

	return;

}
static void SetOmhLvalChar(int code, const char *token, char ch)
{	char str[2];
	str[0] = ch;
	str[1] = '\0';

	SetOmhLvalStr(code, token, str);
}
/***************************************************************************/


int omhlex(void)
{
	int  code;
	int  match;
	int  escape;
	int  i;

	int     eof  = 1;

	char *begin  = "begin";
	char *change = "OMhelpKeyCharacter=";

	int   beginLen  = strlen(begin);
	int   changeLen = strlen(change);


	if( Initialize )
	{	int i;
		for(i = 0; i < n_keyword; i++ )
		{	Key[i] = keyword_table[i].name;
			if( i > 0 )
				assert( strcmp( Key[i], Key[i-1] ) > 0 );
		}
		CurrentLine = 0;
		Ch          = InputGet();
		Initialize  = 0;
		State       = EMPTY_state;
	}

	// maybe opened new file since previous end of file
	if( Ch == eof )
		Ch = InputGet();

	switch( State )
	{
		case EMPTY_state:
		case EOF_state:
		while( State != OMHELP_state )
		{
			switch( State )
			{
				case EOF_state:
				{
					SetOmhLvalChar(
						EOF_lex, "eof", CommandKeyChar
					);
					State          = EMPTY_state;
					return EOF_lex;
				}
				break;

				case EMPTY_state:
				if( Ch == eof )
					State = EOF_state;
				if( Ch == CommandKeyChar )
					State = KEY_state;
				break;

				case KEY_state:
				if( Ch == eof )
					State = EOF_state;
				else if( Ch == begin[0] )
					State = BEGIN_state;
				else if( Ch == change[0] )
					State = CHANGE_state;
				else	State = EMPTY_state;
				break;

				case BEGIN_state:
				match = 1;
				while( State == BEGIN_state )
				{	if( Ch == eof )
						State = EOF_state;
					else if( Ch == CommandKeyChar )
						State = KEY_state;
					else if( Ch == begin[match] )
						match++;
					else	State = EMPTY_state;

					if( match == beginLen )
						State = OMHELP_state;

					Ch = InputGet();
				}
				break;

				case CHANGE_state:
				match = 1;
				while( (State == CHANGE_state) & (match < changeLen) )
				{	if( Ch == eof )
						State = EOF_state;
					else if( Ch == CommandKeyChar )
						State = KEY_state;
					else if( Ch == change[match] )
						match++;
					else	State = EMPTY_state;

					Ch = InputGet();
				}
				if( State == CHANGE_state )
				{
					if( isalpha((int) Ch)) fatalomh(
						"Attempt to set the command "
						"key character to a letter "
						"in A-Z or a-z.",
						NULL
					);
					if( isspace((int) Ch)) fatalomh(
						"Attempt to set the command "
						"key character to a white "
						"space character.",
						NULL
					);
					if( isdigit((int) Ch)) fatalomh(
						"Attempt to set the command "
						"key character to a decimal "
						"digit.",
						NULL
					);
					if( Ch == eof ) fatalomh(
						"Attempt to set the command "
						"key character to the end of "
						"file character.",
						NULL
					);
					CommandKeyChar = Ch;

					Ch    = InputGet();
					State = EMPTY_state;
				}
				break;

				default:
				assert(0);
			}
			Ch = InputGet();
		}
		assert( State == OMHELP_state );

		if( Ch == eof )
		{
			SetOmhLvalChar(EOF_lex, "eof", CommandKeyChar);
			return EOF_lex;
		}
		else
		{	CurrentLine = InputLine();
			SetOmhLvalStr(BEGIN_lex, begin, NULL);
			return BEGIN_lex;
		}
		break;  // ================================================

		case OMHELP_state:
		if( Ch == eof )
		{
			SetOmhLvalChar(EOF_lex, "eof", CommandKeyChar);
			return EOF_lex;
		}
		if( Ch == CommandKeyChar )
		{	// next input character
			Ch = InputGet();

			// check for double dollar ------------------------
			if( Ch == CommandKeyChar )
			{	char str[3];
				str[0] = CommandKeyChar;
				str[1] = CommandKeyChar;
				str[2] = '\0';

				Ch = InputGet();
				SetOmhLvalStr(DOUBLE_DOLLAR_lex, str, NULL);
				return DOUBLE_DOLLAR_lex;
			}

			// check for keyword ------------------------------
			match           = 0;
			Buffer[match++] = CommandKeyChar;
			while( isalpha((int) Ch) )
			{	Buffer[match++] = Ch;
				Ch              = InputGet();
				if( match >= MAX_TOKEN )
				{	Buffer[10] = '\0';
					fatalomh(
						"Keyword beginning with ",
						Buffer,
						" is longer than ",
						int2str(MAX_TOKEN),
						" characters long\n",
						NULL
					);
				}
			}
			Buffer[match] = '\0';

			// skip command key character when matching keywords
			i = BinarySearch(Key, n_keyword, Buffer+1);

			if( i < n_keyword )
			{	code = keyword_table[i].code;

				// check for a change of state
				if( code == LATEX_lex )
					State = LATEX_state;

				if( code == END_lex )
					State = EMPTY_state;

				// skip space following font keywords
				if( Ch == ' ' )
				{	if( (code == FIXED_lex)  |
					    (code == CODE_lex)   |
					    (code == SMALL_lex)  |
					    (code == BIG_lex)    |
					    (code == ITALIC_lex) |
					    (code == BOLD_lex)
					)
					{	Ch = InputGet();
					}
				}

				SetOmhLvalStr(code, Buffer, NULL);
				return code;
			}
			else if( match > 1 ) fatalomh(
				Buffer,
				" is an invalid keyword",
				NULL
			);

			// check for an accent command
			if( Ch == '\'' )
			{	Ch              = InputGet();
				Buffer[match++] = Ch;
				Buffer[match++] = '\0';

				// Ch must be character following command
				Ch              = InputGet();

				SetOmhLvalStr(ACCENT_lex, Buffer, Buffer + 1);
				return ACCENT_lex;
			}


			// check for number following dollar -----------------
			if( isdigit((int) Ch) | (Ch=='.') | (Ch=='+') | (Ch=='-' ) )
			{
				while(
					isdigit((int) Ch) |
					(Ch == '.')   |
					(Ch == '+')   |
					(Ch == '-')
				)
				{	Buffer[match++] = Ch;
					Ch              = InputGet();
					if( match >= MAX_TOKEN )
					{	Buffer[10] = '\0';
						fatalomh(
						"Number beginning with ",
						Buffer,
						" is longer than ",
						int2str(MAX_TOKEN),
						" characters long\n",
						NULL
						);
					}
				}
				Buffer[match] = '\0';
				assert( match > 1 );
				SetOmhLvalStr(NUMBER_lex, Buffer, Buffer + 1);

				return NUMBER_lex;
			}

			// not a valid command
			{	char str[2];
				str[0] = CommandKeyChar;
				str[1] = '\0';

				fatalomh(
				"The command key character ",
				str,
				"\nby itself is not a valid OMhelp token.",
				NULL
				);
			}
		}

		// get text
		match           = 0;
		Buffer[match++] = Ch;
		Ch              = InputGet();
		while( (Ch != eof) & (Ch != CommandKeyChar) )
		{	Buffer[match++] = Ch;
			Ch              = InputGet();
			if( match >= MAX_TOKEN )
			{	Buffer[10] = '\0';
				fatalomh(
					"Text beginning with ",
					Buffer,
					" is longer than ",
					int2str(MAX_TOKEN),
					" characters long\n",
					NULL
				);
			}
		}
		Buffer[match] = '\0';
		SetOmhLvalStr(TEXT_lex, Buffer, Buffer);
		return TEXT_lex;

		case LATEX_state: // =========================================
		if( Ch == eof )
		{
			SetOmhLvalChar(EOF_lex, "eof", CommandKeyChar);

			State = EMPTY_state;
			return EOF_lex;
		}

		// get text
		match           = 0;
		escape          = Ch == '\\';
		Buffer[match++] = Ch;
		Ch              = InputGet();
		while( (Ch != eof) & ((Ch != CommandKeyChar) | escape) )
		{	escape          = Ch == '\\';
			Buffer[match++] = Ch;
			Ch              = InputGet();
			if( match >= MAX_TOKEN )
			{	Buffer[10] = '\0';
				fatalomh(
					"Text beginning with ",
					Buffer,
					" is longer than ",
					int2str(MAX_TOKEN),
					" characters long\n",
					NULL
				);
			}
		}
		Buffer[match] = '\0';

		State = OMHELP_state;
		SetOmhLvalStr(TEXT_lex, Buffer, Buffer);
		return TEXT_lex;

		default:
		assert(0);
	}
	assert(0);
	return 0;
}

void OmhLexSetInputLine(int line)
{	CurrentLine = line; }
